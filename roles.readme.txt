Roles UAVCAN – messages reçus / envoyés
======================================

- ServoRole (`ROLE.servo.pwm`, `ROLE.servo.smart`)
  - Reçoit : `uavcan.equipment.actuator.ArrayCommand` (broadcast), pour piloter PWM ou SmartServo selon le type de commande.
  - Envoie : `uavcan.equipment.actuator.Status` uniquement pour SmartServo et si `role.servo.smart.status_frequency` > 0.
  - Paramètres PWM : `role.servo.pwm.frequency`, `role.servo.pwm.pulse_half_width` (mi-largeur us), `role.servo.pwm.map_index1` (premier servo), `role.servo.pwm.channel_mask` (canaux actifs CH1..CH4).
  - Paramètres Smart : `role.servo.smart.map_index1`, `role.servo.smart.num_servos`, `role.servo.smart.status_frequency` (Hz, 0 = pas de retour).

- Baro_MPL3115A2_Role (`ROLE.i2c.barometer.mpl3115a2`)
  - Reçoit : rien.
  - Envoie : `uavcan.equipment.air_data.StaticPressure`, `uavcan.equipment.air_data.StaticTemperature` (mesures périodiques).

- EscDshot (`ROLE.esc.dshot`)
  - Reçoit : `uavcan.equipment.esc.RawCommand` (broadcast) pour les consignes moteurs.
  - Envoie : `uavcan.equipment.esc.Status` uniquement si la télémétrie bidirectionnelle DSHOT_BIDIR est activée et avec la cadence configurée.
  - Paramètres : `role.esc.dshot.map_index1` (premier ESC), `role.esc.dshot.channel_mask` (canaux actifs CH1..CH4), `role.esc.dshot.cmd_rate` (période en ticks ChibiOS, base `CH_CFG_ST_FREQUENCY`), `role.esc.dshot.rpm_freq_div` (0 = pas de télémétrie bidir).
  - Notes :
    - Le driver bas niveau émet toujours une trame DShot 4 canaux (DMA/TIM). Les canaux masqués sont forcés à MOTOR_STOP (0), et seuls les canaux sélectionnés contiennent une consigne utile.
    - Sur MicroCAN, `channel_mask` sert aussi à configurer les broches partagées via `dynamicPinConfig`.

- SBUS RC (`ROLE.sbus`)
  - Reçoit : rien en UAVCAN (écoute SBUS série).
  - Envoie : `dronecan.sensors.rc.RCInput` (voies SBUS filtrées + flags).
  - Paramètres : `role.sbus.channel_mask` pour sélectionner les voies, `role.sbus.id` pour l’identifiant.
  - Notes : seules les voies actives sont publiées ; qualité/failsafe reflètent les flags SBUS.

- SerialStream (`ROLE.tunnel.serial`)
  - Reçoit : `uavcan.tunnel.Broadcast` (ID 2010) et envoie le payload brut sur l’UART si le protocole correspond.
  - Envoie : `uavcan.tunnel.Broadcast` (flux série lu sur l’UART, segmenté en blocs).
  - Paramètres : `role.tunnel.serial.protocol` (sélecteur de protocole), `bus.serial.baudrate`.

- GpsUBX (`ROLE.gnss.ubx`)
  - Reçoit : rien en UAVCAN (consomme les messages UBX sur l’UART).
  - Envoie : `uavcan.equipment.gnss.Fix2` (NAV-PVT), `uavcan.equipment.gnss.Auxiliary` (NAV-DOP/NAV-SAT).
  - Paramètres : `bus.serial.baudrate`.
  - Notes : acquisition des ressources USART/pins avant démarrage de l’UART ; allocation DMA vérifiée avant de lancer le thread, sinon retour erreur mémoire.

- Magnétomètre QMC5883 (`ROLE.i2c.magnetometer.q5883`)
  - Reçoit : rien.
  - Envoie : `uavcan.equipment.ahrs.MagneticFieldStrength2` à chaque mesure disponible.
  - Paramètres : `role.i2c.magnetometer.q5883.range` (2 ou 8 gauss), `role.i2c.magnetometer.q5883.rot_deg` (0/90/180/270) pour ajuster l’orientation, `role.i2c.magnetometer.q5883.sensor_id` (0–250). ODR/filtre/gain fixés (OSR 256, ODR 50 Hz, mode continu).
  - Notes : utilisation directe d’I2C `i2cMasterTransmitTimeout` avec buffers DMA ; en cas d’erreur I2C, reset bus et reprise.

- HealthSurvey (`ROLE.health.survey`)
  - Reçoit : rien.
  - Envoie : `uavcan.equipment.device.Temperature` (device_id 0, température core en K),
    `uavcan.equipment.power.CircuitStatus` (circuit_id 0 = batterie, circuit_id 1 = 3.3V).

- Led2812 / RGB strip (`ROLE.led2812`)
  - Reçoit : `uavcan.equipment.indication.LightsCommand` (broadcast) pour piloter une bande WS2812 externe.
  - Envoie : rien.
  - Paramètres : `role.led2812.led_number` (1..8).
  - Notes :
    - Utilise le même matériel que le voltmètre (TIM3_CH4 sur PB07 / F0_b selon la carte), donc ne peut pas être activé en même temps que `ROLE.voltmeter`.
    - Sur MicroCAN, acquisition de ressource supplémentaire côté connecteur (`F0`) pour éviter les conflits quand plusieurs broches partagent le même header.

- Voltmeter (`ROLE.voltmeter`)
  - Reçoit : `uavcan.equipment.gnss.Fix2` (pour extinction auto si `role.voltmeter.gps_speed_off_mps` > 0).
  - Envoie : rien.
  - Affichage : jauge de charge sur 8 LEDs WS2812 (vert/jaune/rouge) + clignotement rouge à vide.
  - Paramètres : `role.voltmeter.cells` (2..6), `role.voltmeter.brightness` (0..1),
    `role.voltmeter.gps_speed_off_mps` (m/s, 0 = désactivé).
  - Notes :
    - La conversion tension->% n’est pas linéaire : lookup table LiPo (tension par cellule).
    - Seuil "vide" : 3.4V/cellule (clignotement rouge), "plein" : 4.2V/cellule (8 vertes fixes).
    - Pour économiser la batterie, si un `uavcan.equipment.gnss.Fix2` valide est reçu et que la vitesse sol
      dépasse `role.voltmeter.gps_speed_off_mps`, les LEDs sont éteintes.
    - Matériel partagé avec `ROLE.led2812` : mutualisation TIM3/PB07 et, sur MicroCAN, le connecteur `F0`.

Services/protocoles gérés par le nœud (pubSub/UAVCanSlave)
-----------------------------------------------------------
- Diffusion périodique : `uavcan.protocol.NodeStatus`.
- Gestion ID dynamique : `uavcan.protocol.dynamic_node_id.Allocation` (req/broadcast).
- Services de base : réponse à `uavcan.protocol.GetNodeInfo` (et client pour récupérer des infos si besoin).
- Paramètres : `uavcan.protocol.param.GetSet` (req/res), `uavcan.protocol.param.ExecuteOpcode` (save/erase).
  - Comportement lors d’un `GetSet` d’écriture : `uavcan.param_set_behavior`
    - `0` (`SetRam`) : modifie uniquement en RAM (jusqu’au reboot).
    - `1` (`SetRamFlash`) : modifie en RAM + sauvegarde en flash du paramètre modifié.
    - `2` (`SetRamFlashAndReboot`) : modifie en RAM + sauvegarde en flash + redémarrage du nœud.
- Redémarrage : `uavcan.protocol.RestartNode` (req/res).
- Mise à jour firmware : `uavcan.protocol.file.BeginFirmwareUpdate` (req/res) + `uavcan.protocol.file.Read` (client) pour récupérer l’image.
- Réception passive : souscription aux `uavcan.protocol.NodeStatus` reçus (monitoring).

Remarque : les rôles sont instanciés au démarrage selon les paramètres persistants et utilisent `sendBroadcast` du nœud UAVCAN. Les services ci-dessus sont fournis par la couche pubSub/UAVCanSlave indépendamment des rôles applicatifs. Si `ROLE.identification` est vrai, la carte passe en mode identification (LED interne) et le nœud UAVCAN n’est pas démarré.
